
@implements IDialogContentComponent<TribEdificaco>
@inject ITribItbidocumentoTipoAppService tribItbidocumentoTipoAppService
@inject IJSRuntime JSRuntime
    
<FluentCard Justify="@JustifyContent.Center">
    <FluentTextField @bind-Value="@Content.InscricaoImobiliaria">Inscrição Imobiliária:</FluentTextField>
    <FluentNumberField @bind-Value="@Content.EdificacaoId">EdificacaoID:</FluentNumberField>
    <FluentTextField @bind-Value="@Content.EdifMatricula">Matrícula:</FluentTextField>
    <FluentTextField @bind-Value="@Content.EdifCaracteristica">Caracteristica</FluentTextField>
    <FluentNumberField @bind-Value="@Content.EdifNumOficio">Número do Ofício:</FluentNumberField>
    <FluentNumberField @bind-Value="@Content.Terreno.TerrAreaTerreno">Área do Terreno</FluentNumberField>
    <FluentNumberField @bind-Value="@Content.EdifAreaConstruida">Área do Construída</FluentNumberField>
    <FluentNumberField @bind-Value="@Content.EdifFracaoIdealEdificacao">Fração</FluentNumberField>
</FluentCard>


<!--

<FluentCard Justify="@JustifyContent.Center">
    <FluentDataGrid Items=@docsExigidosQ TGridItem=TribItbidocumentoTipo>
        <PropertyColumn Title="Documento Obrigatório" Property="@(c => c!.ItbidsDocumento)" Sortable="true" Align=Align.Start />
        <TemplateColumn Title="UpLoad" Sortable="true" Align=Align.Start>
            @{
                var item = context as TribItbidocumentoTipo;
                <FluentButton Appearance="Appearance.Accent" Id="MyUploadBuffer" >
                    Carregar
                </FluentButton>
            }
        </TemplateColumn>
    </FluentDataGrid>
</FluentCard>
-->
<FluentCard Justify="@JustifyContent.Center">
    <FluentDataGrid Items=@AnexosExigidosQ TGridItem=Anexo>
        <PropertyColumn Title="Documento Obrigatório" Property="@(c => c!.Doc.ItbidsDocumento)" Sortable="true" Align=Align.Start />
        <PropertyColumn Title="Arquivo" Property="@(c => c!.nomearquivo)" Sortable="true" Align=Align.Start />
        <TemplateColumn Title="Ação" Sortable="true" Align=Align.Start>
            @{
                var item = context as Anexo;
                if (item.carregado)
                {
                    <FluentButton Appearance="Appearance.Accent" OnClick="()=>OpenFileSelector(item)">
                        Excluir
                    </FluentButton>
                }
                else
                {
                    
                    <FluentButton Appearance="Appearance.Accent" OnClick="()=>OpenFileSelector(item)">
                        Carregar
                    </FluentButton>
                }
            }
        </TemplateColumn>
    </FluentDataGrid>
</FluentCard>
<FluentCard Justify="@JustifyContent.Center">
    <FluentInputFile @ref="@myFileByBuffer"
                     AnchorId="MyUploadBuffer"
                     DragDropZoneVisible="false"
                     Mode="InputFileMode.Buffer"
                     Multiple="true"
                     MaximumFileSize="@(1000 * 1024 * 1024)"
                     Accept=".mp4, .mov, .avi"
                     OnInputFileChange="OnProgressChangeAsyncBF"

                     OnCompleted="@OnCompleted" />

    <FluentProgress Visible="@(progressPercent > 0)" Min="0" Max="100" Value="@progressPercent" />
    <FluentLabel Alignment="HorizontalAlignment.Center">
        @progressTitle
    </FluentLabel>

    <!--    
                    Id="MyUploadBuffer" OnClick="()=>OpenFileSelector(item)"> 
                     OnProgressChange="@OnProgressChangeAsyncBF"
    <FluentButton Appearance="Appearance.Accent" Id="MyUploadBuffer">
        Upload files
    </FluentButton>

    <FluentButton @onclick="@((e) => IsCanceled = true)">
        Cancel
    </FluentButton>
    -->

    @if (Files.Any())
    {
        <h4>File(s) uploaded:</h4>
        <ul>
            @foreach (var file in Files)
            {
                <li>
                    @file.Value
                </li>
            }
        </ul>
    }


</FluentCard>

@code {
    private string buttonLabel = "Carregar";
    private Anexo currentAnexo;
    [Parameter]
    public TribEdificaco Content { get; set; } = default!;
    public TribItbidocumentoTipoSpec tribItbidocumentoTipoSpec = new TribItbidocumentoTipoSpec("Imóvel");
    public IEnumerable<TribItbidocumentoTipo> docsExigidos { get; set; }
    //public IQueryable<TribItbidocumentoTipo>? docsExigidos { get; set; }
    //public IEnumerable<TribItbidocumentoTipo>? docsExigidos { get; set; }
    public IQueryable<TribItbidocumentoTipo>? docsExigidosQ { get; set; }
    public IQueryable<Anexo>? AnexosExigidosQ { get; set; } 
    [CascadingParameter]
    public FluentDialog? Dialog { get; set; }
    private List<IBrowserFile> filesBf = new List<IBrowserFile>();
    //private List<IBrowserFile> filesBfdefinitivo = new List<IBrowserFile>();
    private Dictionary<string, bool> itemStates = new Dictionary<string, bool>();
    FluentInputFile? myFileByBuffer = default!;
    int? progressPercent;
    string? progressTitle;
    bool IsCanceled;

    Dictionary<int, string> Files = new();
    //Dictionary<TribItbidocumentoTipo, InputFile> docsexigidosDicionario = new();

    [Parameter]
    //public EventCallback<List<IBrowserFile>> AnexosImovelChanged { get; set; }
    public EventCallback<Anexo> AnexosImovelChanged { get; set; }
    //public EventCallback<List<byte[]>> AnexosImovelChanged { get; set; }
    async Task OnProgressChangeAsync(FluentInputFileEventArgs file)
    {
        progressPercent = file.ProgressPercent;
        progressTitle = file.ProgressTitle;

        // To cancel?
        file.IsCancelled = IsCanceled;

        // New file
        if (!Files.ContainsKey(file.Index))
        {
            var localFile = Path.GetTempFileName() + file.Name;
            Files.Add(file.Index, localFile);
        }

        // Write to the FileStream
        await file.Buffer.AppendToFileAsync(Files[file.Index]);
    }
    private async void OpenFileSelector(Anexo anexo)
    {
        if (anexo.carregado)
        {
            if (itemStates.ContainsKey(anexo.nomearquivo))
            {
                itemStates.Remove(anexo.nomearquivo);
                // var fileToRemove = filesBf.FirstOrDefault(f => f.Name == anexo.nomearquivo);
                var fileToRemove = currentAnexo.AnexoBf.FirstOrDefault(f => f.Name == anexo.nomearquivo);
                if (fileToRemove != null)
                {
                    currentAnexo.AnexoBf.Remove(fileToRemove);
                    StateHasChanged();
                }
                currentAnexo.carregado = false;

                //atualistaAnexosExigidosQ(f.Name);

                currentAnexo.nomearquivo = "";
                currentAnexo.nomeDEFINITIVO = "";
                //  atualistaAnexosExigidosQ(currentAnexo);

                //var extensao = Path.GetExtension(anexo.nomearquivo);
                //var nomedefinitivo = anexo.Doc.ItbidocId.ToString() + '-' + Content.InscricaoImobiliaria.ToString() + '.' + extensao;
                //filesBfdefinitivo = filesBf;

                await AnexosImovelChanged.InvokeAsync(currentAnexo);
                StateHasChanged();
            }

        }
        else
        {
            currentAnexo = anexo;
            myFileByBuffer?.ShowFilesDialogAsync();
        }
    }
    async Task OnProgressChangeAsyncBF(InputFileChangeEventArgs file)
    {
        if (currentAnexo != null)
        {
            // Process the file and the currentAnexo
            // Your code to handle the file upload
            // currentAnexo.nomearquivo=file
        }

        var inputFile = file.GetMultipleFiles();
        if(inputFile != null)
        {
            foreach(var f in inputFile )
            {
                //bool carregado = AnexosExigidosQ.Where(a=> a.Doc.ItbidsDocumento );

                if (itemStates.ContainsKey(f.Name))
                {
                    itemStates.Remove(f.Name);
                    // var fileToRemove = filesBf.FirstOrDefault(f => f.Name == f.Name);
                    var fileToRemove = currentAnexo.AnexoBf.FirstOrDefault(f => f.Name == f.Name);
                    if (fileToRemove!=null)
                    {
                        //filesBf.Remove(fileToRemove);
                        currentAnexo.AnexoBf.Remove(fileToRemove);
                        StateHasChanged();
                    }
                    currentAnexo.carregado = false;

                    //atualistaAnexosExigidosQ(f.Name);
                    currentAnexo.nomearquivo = "";
                    //  atualistaAnexosExigidosQ(currentAnexo);
                    StateHasChanged();
                }
                else
                {
                    //  docsExigidosQ.Append(new TribItbidocumentoTipo(){ItbidsDocumento=f.Name});

                    itemStates.Add(f.Name,true);
                    var extensao = Path.GetExtension(f.Name);
                    currentAnexo.nomeDEFINITIVO = currentAnexo.Doc.ItbidocId.ToString() + '-' + Content.InscricaoImobiliaria.ToString() +  extensao;
                    //f.Name = currentAnexo.nomeDEFINITIVO;
                    //filesBfdefinitivo = filesBf;

                    //filesBf.Add(f);
                    currentAnexo.AnexoBf.Add(f);
                    //filesBf.Add(new });
                    //atualistaAnexosExigidosQ(f.Name);
                    currentAnexo.nomearquivo = f.Name;
                    currentAnexo.carregado = true;
                    StateHasChanged();
                    // atualistaAnexosExigidosQ(currentAnexo);
                }

            }
            StateHasChanged();
            
            await AnexosImovelChanged.InvokeAsync(currentAnexo);
        }

    }

    void OnCompleted(IEnumerable<FluentInputFileEventArgs> files)
    {
        progressPercent = myFileByBuffer!.ProgressPercent;
        progressTitle = myFileByBuffer!.ProgressTitle;

        // For the demo, delete these files.
        foreach (var file in Files)
        {
            File.Delete(file.Value);
        }
    }
    protected override async Task OnInitializedAsync()
    {
        List<Anexo> listdoc = new List<Anexo>();
        docsExigidos = await tribItbidocumentoTipoAppService.ListAsync(tribItbidocumentoTipoSpec, CancellationToken.None);
        docsExigidosQ = docsExigidos.AsQueryable();

        foreach(var doc in docsExigidosQ)
        {
            listdoc.Add(new Anexo() { Doc = doc,carregado=false,nomearquivo=null } );
        }
        AnexosExigidosQ = listdoc.AsQueryable();

        await base.OnInitializedAsync();
    }
    private void atualistaAnexosExigidosQ(Anexo arquivo)
    {
        List<Anexo> listdoc = new List<Anexo>();
        listdoc = AnexosExigidosQ.ToList();

        var encontrado = listdoc.Find(d => d.nomearquivo == arquivo.nomearquivo);
        //var f = filesBf.Where()
        


        if (encontrado != null)
        {
            //listdoc.Add(new Anexo() { nomearquivo=arquivo.nomearquivo });
            listdoc.Remove(arquivo);

        } else 
        {
            listdoc.Add(new Anexo() { nomearquivo = arquivo.nomearquivo });
        }
        AnexosExigidosQ = listdoc.AsQueryable();
        StateHasChanged();
    }
    private Icon GetIcon(string item)
    {
        
        
        if (item == "Excluir")
        {
            return itemStates.TryGetValue("Carregar", out bool isAdded2) && isAdded2
         ? new Icons.Regular.Size24.SubtractSquare().WithColor(Color.Success)
         : new Icons.Regular.Size24.AddSquare().WithColor(Color.Success);
        }
        // Retorna o ícone de exclusão se o item foi adicionado, caso contrário, retorna o ícone de adição
        return itemStates.TryGetValue("Excluir", out bool isAdded) && isAdded
         ? new Icons.Regular.Size24.SubtractSquare().WithColor(Color.Accent)
         : new Icons.Regular.Size24.AddSquare().WithColor(Color.Accent);
    }


}